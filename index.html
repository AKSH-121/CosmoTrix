<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Rover Rush ‚Äî Triangulation Runner</title>
<style>
:root{
  --bg1:#0a0f1e; --bg2:#0e1630; --grid:#152448;
  --neon:#28f0ff; --accent:#7bff79; --warn:#ff6a6a; --gold:#ffd66b;
  --glass:rgba(255,255,255,.07); --glass-b:rgba(255,255,255,.14); --text:#e9f4ff;
}
*{box-sizing:border-box}
html,body{height:100%;margin:0}
body{
  font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, 'Helvetica Neue', Arial;
  background: radial-gradient(1200px 600px at 70% 0%, #17213f 0%, var(--bg1) 55%, var(--bg2) 100%);
  color:var(--text);
  display:flex; align-items:center; justify-content:center;
}
.wrap{ width:min(1050px,100%); padding:12px; display:grid; grid-template-columns: 1fr 300px; gap:12px }
@media (max-width: 980px){ .wrap{ grid-template-columns:1fr } }
.card{
  position:relative; border:1px solid var(--glass-b); border-radius:16px; overflow:hidden;
  background:linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
  box-shadow:0 10px 30px rgba(0,0,0,.35), inset 0 0 0 1px rgba(255,255,255,.03);
  backdrop-filter: blur(6px);
}
#game{
  display:block; width:100%; height:auto;
  background:
    linear-gradient(0deg, transparent 24%, var(--grid) 25% 26%, transparent 27% 74%, var(--grid) 75% 76%, transparent 77%),
    linear-gradient(90deg, transparent 24%, var(--grid) 25% 26%, transparent 27% 74%, var(--grid) 75% 76%, transparent 77%),
    radial-gradient(800px 500px at 50% 80%, rgba(37,240,255,.05), transparent 60%);
  background-size: 60px 60px, 60px 60px, auto;
}
.overlay{ position:absolute; inset:0; pointer-events:none; }
.topbar{ position:absolute; top:8px; left:8px; right:8px; display:flex; align-items:center; justify-content:space-between; gap:8px; pointer-events:auto; }
.badge{ background:var(--glass); border:1px solid var(--glass-b); border-radius:12px; padding:6px 10px; font-size:12px; box-shadow: inset 0 0 0 1px rgba(255,255,255,.04); }
.btn{ cursor:pointer; user-select:none; -webkit-user-select:none; border-radius:12px; padding:6px 12px; border:1px solid var(--glass-b); background:linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.03)); }
.btn:active{ transform: translateY(1px); filter: brightness(1.05) }
.hud{ display:flex; flex-direction:column; gap:12px; padding:14px; border:1px solid var(--glass-b); background:linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.025)); border-radius:16px; backdrop-filter: blur(6px); }
.hud h2{ margin:0 0 6px 0; font-size:18px }
.row{ display:flex; align-items:center; justify-content:space-between; gap:10px }
.kv{ font-size:13px }
.sep{ height:1px; background:rgba(255,255,255,.08) }
.bar{ height:8px; background:rgba(255,255,255,.1); border-radius:999px; overflow:hidden; flex:1 }
.fill{ height:100%; width:0%; background:linear-gradient(90deg, var(--accent), var(--neon)) }
.controls{ display:grid; grid-template-columns:repeat(3,56px); grid-template-rows:repeat(3,56px); gap:8px; justify-content:center }
.ctrl{ display:flex; align-items:center; justify-content:center; border:1px solid var(--glass-b); border-radius:12px; background:linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.03)); font-weight:700; }
.foot{ font-size:12px; opacity:.85 }
canvas.minimap{
  position:absolute; top:52px; left:8px; width:180px; height:180px; border-radius:12px; border:1px solid var(--glass-b);
  background:linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
  box-shadow: inset 0 0 0 1px rgba(255,255,255,.04);
}
</style>
</head>
<body>
<div class="wrap">
  <div class="card" aria-label="Rover Rush gameplay">
    <div class="topbar">
      <div class="badge">üöÄ Rover Rush ‚Äî Triangulation Runner</div>
      <div style="display:flex; gap:8px">
        <button class="btn" id="pauseBtn">Pause</button>
        <button class="btn" id="resetBtn">Reset</button>
        <label class="badge" style="cursor:pointer">
          <input id="assistToggle" type="checkbox" checked /> Aim Assist (arrow)
        </label>
      </div>
    </div>
    <canvas id="game" width="960" height="600"></canvas>
    <canvas id="minimap" class="minimap" width="180" height="180"></canvas>
    <div class="overlay" id="overlay"></div>
  </div>

  <div class="hud">
    <h2>HUD</h2>
    <div class="row kv"><span>Score</span><strong id="score">0</strong></div>
    <div class="row kv"><span>Speed</span><span id="speed">1.0x</span></div>
    <div class="row kv"><span>Lives</span><span id="lives">3</span></div>
    <div class="sep"></div>
    <div class="kv"><strong>Signal Strength to Next Beacon</strong></div>
    <div class="row">
      <span>A</span><div class="bar"><div id="sigA" class="fill"></div></div><span id="dA">‚Äî</span>
    </div>
    <div class="row">
      <span>B</span><div class="bar"><div id="sigB" class="fill"></div></div><span id="dB">‚Äî</span>
    </div>
    <div class="row">
      <span>C</span><div class="bar"><div id="sigC" class="fill"></div></div><span id="dC">‚Äî</span>
    </div>
    <div class="sep"></div>
    <div class="controls" aria-label="On-screen controls">
      <div></div>
      <div class="ctrl" data-dir="up">‚ñ≤</div>
      <div></div>
      <div class="ctrl" data-dir="left">‚óÄ</div>
      <div class="ctrl" data-dir="stop">‚èπ</div>
      <div class="ctrl" data-dir="right">‚ñ∂</div>
      <div></div>
      <div class="ctrl" data-dir="down">‚ñº</div>
      <div></div>
    </div>
    <div class="foot">
      swipe / WASD / arrows to change lanes. pass through glowing beacon gates, avoid rocks.
      triangulation minimap shows 3 tower circles ‚Üí overlap ‚âà beacon. built by students ‚Äî plug this into your site sections.
    </div>
  </div>
</div>

<script>
(()=>{
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;

  // Minimap
  const map = document.getElementById('minimap');
  const mctx = map.getContext('2d');
  const MW = map.width, MH = map.height;

  // Lanes
  const laneCount = 3;
  const lanes = [W*0.30, W*0.50, W*0.70];
  let currentLane = 1;

  // Game state
  let speed = 8;
  let speedFactor = 1.0;
  let score = 0;
  let lives = 3;
  let paused = false; // keep original behavior: game runs on load
  let time = 0;

  const rover = { x: lanes[currentLane], y: H*0.8, radius: 20, laneTween: 0, laneFrom: 1, laneTo: 1 };

  const towers = [
    {id:'A', x: 30, y: 30, hue:180},
    {id:'B', x: 150, y: 35, hue:120},
    {id:'C', x: 90, y: 155, hue:280}
  ];

  let nextBeacon = spawnBeacon();

  // Obstacles
  const obstacles = [];
  function spawnObstacle(){
    const lane = Math.floor(Math.random()*laneCount);
    const x = lanes[lane];
    obstacles.push({ x, y: -60, w: 44, h: 32, hit:false });
  }

  function spawnBeacon(){
    const lane = Math.floor(Math.random()*laneCount);
    const x = lanes[lane];
    const y = -200 - Math.random()*200;

    const bx = mapLaneToMinimapX(lane);
    const by = 90;

    const radii = towers.map(t => Math.hypot(bx - t.x, by - t.y));
    return { lane, x, y, bx, by, radii, hit:false, passed:false, glow:0 };
  }

  function mapLaneToMinimapX(lane){
    const xs = [45, 90, 135];
    return xs[lane];
  }

  // UI refs
  const scoreEl = document.getElementById('score');
  const speedEl = document.getElementById('speed');
  const livesEl = document.getElementById('lives');
  const dAEl = document.getElementById('dA');
  const dBEl = document.getElementById('dB');
  const dCEl = document.getElementById('dC');
  const sigA = document.getElementById('sigA');
  const sigB = document.getElementById('sigB');
  const sigC = document.getElementById('sigC');
  const pauseBtn = document.getElementById('pauseBtn');
  const resetBtn = document.getElementById('resetBtn');
  const assistToggle = document.getElementById('assistToggle');

  pauseBtn.onclick = ()=>{
    paused = !paused;
    pauseBtn.textContent = paused ? 'Resume' : 'Pause';
  };
  resetBtn.onclick = ()=> reset();

  function reset(){
    speed = 8; speedFactor = 1.0; score=0; lives=3; time=0;
    obstacles.length=0;
    nextBeacon = spawnBeacon();
    currentLane = 1;
    rover.x = lanes[1];
    rover.laneTween = 0; rover.laneFrom = 1; rover.laneTo = 1;
    paused = false;
    pauseBtn.textContent = 'Pause';
  }

  // Input
  const keys = new Set();
  document.addEventListener('keydown', e=>{
    const k = e.key.toLowerCase();
    if (['arrowleft','a','arrowright','d','arrowup','w','arrowdown','s'].includes(k)) e.preventDefault();
    keys.add(k);
  });
  document.addEventListener('keyup', e=> keys.delete(e.key.toLowerCase()));

  document.querySelectorAll('.ctrl').forEach(btn=>{
    const dir = btn.dataset.dir;
    const act = ()=>{
      if(dir==='left') changeLane(-1);
      if(dir==='right') changeLane(+1);
      if(dir==='up') speedBoost(+0.15);
      if(dir==='down') speedBoost(-0.15);
      if(dir==='stop'){ paused = !paused; pauseBtn.textContent = paused?'Resume':'Pause'; }
    };
    btn.addEventListener('pointerdown', act);
  });

  // Swipe
  let touchStart=null;
  canvas.addEventListener('touchstart', e=>{
    if(e.touches[0]) touchStart = {x:e.touches[0].clientX, y:e.touches[0].clientY};
  }, {passive:true});
  canvas.addEventListener('touchend', e=>{
    if(!touchStart) return;
    const t = touchStart; touchStart=null;
    const dx = (e.changedTouches[0].clientX - t.x);
    const dy = (e.changedTouches[0].clientY - t.y);
    if(Math.abs(dx) > Math.abs(dy)){
      if(dx < -20) changeLane(-1);
      else if(dx > 20) changeLane(+1);
    }else{
      if(dy < -20) speedBoost(+0.15);
      else if(dy > 20) speedBoost(-0.15);
    }
  }, {passive:true});

  function changeLane(delta){
    const target = Math.max(0, Math.min(laneCount-1, currentLane + delta));
    if(target !== currentLane){
      rover.laneFrom = currentLane; rover.laneTo = target; rover.laneTween = 0;
      currentLane = target;
    }
  }
  function speedBoost(df){ speedFactor = Math.max(0.6, Math.min(2.0, speedFactor + df)); }

  // Game loop
  let last = performance.now();
  function frame(now){
    const dt = Math.min(50, now-last); last = now;
    if(!paused){ update(dt); draw(now); }
    requestAnimationFrame(frame);
  }

  function update(dt){
    time += dt;

    if (tapKey(['arrowleft','a'])) changeLane(-1);
    if (tapKey(['arrowright','d'])) changeLane(+1);
    if (tapKey(['arrowup','w'])) speedBoost(+0.05);
    if (tapKey(['arrowdown','s'])) speedBoost(-0.05);

    speed = 8 * speedFactor + Math.min(10, Math.floor(time/5000));

    if (rover.laneTween < 1){
      rover.laneTween = Math.min(1, rover.laneTween + dt/180);
      const fromX = lanes[rover.laneFrom], toX = lanes[rover.laneTo];
      rover.x = fromX + (toX - fromX) * easeOutCubic(rover.laneTween);
    } else {
      rover.x = lanes[currentLane];
    }

    for(const o of obstacles){ o.y += speed; }
    nextBeacon.y += speed;

    if (time % 900 < 18){
      if (Math.random() < 0.6) spawnObstacle();
    }

    for (let i=obstacles.length-1;i>=0;i--){
      if (obstacles[i].y > H+80) obstacles.splice(i,1);
    }

    for(const o of obstacles){
      if(!o.hit && Math.abs(o.x - rover.x) < 32 && Math.abs(o.y - rover.y) < 26){
        o.hit = true;
        lives -= 1; bump();
        if (lives <= 0) gameOver();
      }
    }

    if (!nextBeacon.passed && Math.abs(nextBeacon.y - rover.y) < 20){
      if (Math.abs(lanes[nextBeacon.lane] - rover.x) < 30){
        nextBeacon.hit = true; nextBeacon.passed = true; nextBeacon.glow = 1;
        score += 100; speedBoost(+0.05);
      } else {
        score = Math.max(0, score - 20);
      }
    }

    if (nextBeacon.y > H + 60){ nextBeacon = spawnBeacon(); }

    const dists = nextBeacon.radii;
    const maxD = 180;

    dAEl.textContent = dists[0].toFixed(0);
    dBEl.textContent = dists[1].toFixed(0);
    dCEl.textContent = dists[2].toFixed(0);

    sigA.style.width = `${(100*(1 - clamp(dists[0]/maxD,0,1))).toFixed(0)}%`;
    sigB.style.width = `${(100*(1 - clamp(dists[1]/maxD,0,1))).toFixed(0)}%`;
    sigC.style.width = `${(100*(1 - clamp(dists[2]/maxD,0,1))).toFixed(0)}%`;

    scoreEl.textContent = score;
    speedEl.textContent = `${speedFactor.toFixed(1)}x`;
    livesEl.textContent = lives;
  }

  function draw(now){
    ctx.clearRect(0,0,W,H);
    drawParallax(now);
    drawRoad();

    if (assistToggle && assistToggle.checked){
      drawAssistArrow(nextBeacon.lane);
    }

    drawBeaconGate(nextBeacon);
    for(const o of obstacles) drawObstacle(o);
    drawRover();

    if (hitFlash > 0){
      ctx.fillStyle = `rgba(255, 100, 100, ${hitFlash})`;
      ctx.fillRect(0,0,W,H);
      hitFlash = Math.max(0, hitFlash - 0.05);
    }

    ctx.fillStyle='rgba(255,255,255,.9)';
    ctx.font='12px system-ui';
    ctx.fillText('Score ' + score, 10, 16);

    drawMinimap(now);
  }

  // ==== Drawing helpers ====
  function drawParallax(now){
    const t = now*0.0002;
    for(let i=0;i<3;i++){
      ctx.fillStyle = `rgba(255,255,255,${0.05 + 0.05*i})`;
      for(let s=0;s<40;s++){
        const x = (s*187 + (t*200*(i+1))) % W;
        const y = (s*53 + (t*120*(i+1))) % (H*0.5);
        ctx.fillRect(x, y, 2, 2);
      }
    }
  }

  function drawRoad(){
    ctx.save();
    const roadW = W*0.56;
    ctx.fillStyle = 'rgba(20,30,55,.85)';
    ctx.beginPath();
    ctx.moveTo(W*0.22, 0);
    ctx.lineTo(W*0.78, 0);
    ctx.lineTo(W*0.72, H);
    ctx.lineTo(W*0.28, H);
    ctx.closePath();
    ctx.fill();

    ctx.strokeStyle = 'rgba(255,255,255,.15)';
    ctx.setLineDash([18,18]);
    ctx.lineWidth=2;
    for (let i=1;i<laneCount;i++){
      const x = (lanes[i-1]+lanes[i])/2;
      ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, H); ctx.stroke();
    }
    ctx.setLineDash([]);
    ctx.restore();
  }

  function drawObstacle(o){
    ctx.save();
    ctx.translate(o.x, o.y);
    ctx.fillStyle = o.hit ? 'rgba(255,120,120,.9)' : 'rgba(80,90,120,1)';
    roundRect(-22,-16,44,32,8, true);
    ctx.fillStyle='rgba(255,255,255,.8)';
    ctx.fillRect(-10,-2,4,4);
    ctx.fillRect(6,-2,4,4);
    ctx.restore();
  }

  function drawRover(){
    const r=rover.radius;
    ctx.save();
    ctx.translate(rover.x, rover.y);
    ctx.fillStyle='rgba(0,0,0,.3)';
    ctx.beginPath(); ctx.ellipse(0, r*0.6, r*1.2, r*0.6, 0, 0, Math.PI*2); ctx.fill();

    const g = ctx.createLinearGradient(-r,-r,r,r);
    g.addColorStop(0,'rgba(210,230,255,.95)');
    g.addColorStop(1,'rgba(130,160,230,.95)');
    ctx.fillStyle=g; ctx.strokeStyle='rgba(255,255,255,.5)';
    roundRect(-r, -r*0.8, r*2, r*1.6, 8, true, true);

    ctx.fillStyle='rgba(40,50,70,1)';
    roundRect(-r*0.95, -r*0.9, 16, 20, 6, true);
    roundRect(r*0.95-16, -r*0.9, 16, 20, 6, true);
    roundRect(-r*0.95, r*0.9-20, 16, 20, 6, true);
    roundRect(r*0.95-16, r*0.9-20, 16, 20, 6, true);

    ctx.fillStyle='rgba(90,110,180,1)';
    ctx.fillRect(r*0.4, -r*1.1, 4, r*1.2);

    ctx.strokeStyle='rgba(40,230,255,.5)';
    ctx.setLineDash([5,6]); ctx.lineWidth=2;
    ctx.beginPath(); ctx.arc(r*1.0, 0, r*1.4, -0.7, 0.7); ctx.stroke();
    ctx.setLineDash([]);
    ctx.restore();
  }

  function drawBeaconGate(b){
    const w = 86, h = 14;
    ctx.save();
    const gg = ctx.createRadialGradient(b.x, b.y, 6, b.x, b.y, 120);
    gg.addColorStop(0, 'rgba(120,220,255,.12)');
    gg.addColorStop(1, 'rgba(120,220,255,0)');
    ctx.fillStyle=gg;
    ctx.beginPath(); ctx.arc(b.x, b.y, 120, 0, Math.PI*2); ctx.fill();

    ctx.fillStyle='rgba(120,220,255,.9)';
    roundRect(b.x - w/2, b.y- h/2, w, h, 6, true);

    ctx.fillStyle='rgba(120,160,255,.9)';
    roundRect(b.x - w/2 - 10, b.y-24, 10, 48, 6, true);
    roundRect(b.x + w/2, b.y-24, 10, 48, 6, true);

    if (b.glow > 0){
      ctx.fillStyle = `rgba(255,255,180,${b.glow})`;
      roundRect(b.x - w/2 - 14, b.y-28, w+28, 56, 10, true);
      b.glow = Math.max(0, b.glow - 0.05);
    }
    ctx.restore();
  }

  function drawAssistArrow(targetLane){
    const tx = lanes[targetLane];
    const dx = tx - rover.x;
    const dir = Math.sign(dx);
    if (dir === 0) return;
    ctx.save();
    const alpha = 0.75;
    ctx.fillStyle = `rgba(255,214,107,${alpha})`;
    const baseX = rover.x + dir*42, baseY = rover.y - 46;
    ctx.beginPath();
    ctx.moveTo(baseX, baseY);
    ctx.lineTo(baseX + dir*28, baseY+14);
    ctx.lineTo(baseX, baseY+28);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
  }

  // Minimap
  function drawMinimap(now){
    mctx.clearRect(0,0,MW,MH);
    mctx.strokeStyle='rgba(255,255,255,.08)'; mctx.lineWidth=1;
    for(let i=30;i<MW;i+=30){ mctx.beginPath(); mctx.moveTo(i,0); mctx.lineTo(i,MH); mctx.stroke(); }
    for(let j=30;j<MH;j+=30){ mctx.beginPath(); mctx.moveTo(0,j); mctx.lineTo(MW,j); mctx.stroke(); }

    towers.forEach((t)=>{ drawMiniTower(t, now); });

    nextBeacon.radii.forEach((r,i)=>{
      const t = towers[i];
      const hue = towers[i].hue;
      mctx.setLineDash([8,8]); mctx.lineWidth = 2;
      mctx.strokeStyle = `hsla(${hue}, 90%, 60%, .25)`;
      mctx.beginPath(); mctx.arc(t.x, t.y, r, 0, Math.PI*2); mctx.stroke();
      mctx.setLineDash([]);
      mctx.fillStyle = `hsla(${hue}, 85%, 60%, .04)`;
      mctx.beginPath(); mctx.arc(t.x, t.y, r, 0, Math.PI*2); mctx.fill();
    });

    const pts = circleIntersectionsMini();
    if (pts.length){
      const cx = pts.reduce((s,p)=>s+p.x,0)/pts.length;
      const cy = pts.reduce((s,p)=>s+p.y,0)/pts.length;
      const g = mctx.createRadialGradient(cx, cy, 3, cx, cy, 40);
      g.addColorStop(0,'rgba(255,255,255,.35)');
      g.addColorStop(1,'rgba(255,255,255,0)');
      mctx.fillStyle = g; mctx.beginPath(); mctx.arc(cx, cy, 40, 0, Math.PI*2); mctx.fill();
      mctx.fillStyle='rgba(255,255,255,.9)'; mctx.beginPath(); mctx.arc(cx, cy, 2, 0, Math.PI*2); mctx.fill();
    }

    mctx.fillStyle='rgba(255,220,120,1)';
    mctx.beginPath(); mctx.arc(nextBeacon.bx, nextBeacon.by, 3, 0, Math.PI*2); mctx.fill();

    const rx = mapLaneToMinimapX(currentLane), ry = 160;
    mctx.fillStyle='rgba(130,170,240,1)';
    mctx.beginPath(); mctx.arc(rx, ry, 3, 0, Math.PI*2); mctx.fill();
    mctx.font='10px system-ui'; mctx.fillStyle='rgba(255,255,255,.85)';
    mctx.fillText('R', rx+5, ry+4);
    mctx.fillText('B', nextBeacon.bx+5, nextBeacon.by+4);
  }

  function drawMiniTower(t, now){
    const base = (now*0.002)%1;
    mctx.fillStyle = `hsla(${t.hue}, 80%, 60%, 1)`;
    mctx.beginPath();
    mctx.moveTo(t.x-6, t.y+8);
    mctx.lineTo(t.x+6, t.y+8);
    mctx.lineTo(t.x, t.y-8);
    mctx.closePath();
    mctx.fill();

    mctx.strokeStyle = `hsla(${t.hue}, 80%, 75%, .9)`;
    mctx.lineWidth=1;
    mctx.beginPath();
    mctx.moveTo(t.x, t.y-8);
    mctx.lineTo(t.x, t.y-16);
    mctx.stroke();

    mctx.fillStyle = `hsla(${t.hue}, 90%, 70%, 1)`;
    mctx.beginPath(); mctx.arc(t.x, t.y-18, 2, 0, Math.PI*2); mctx.fill();

    for(let i=0;i<3;i++){
      const p = (base + i*0.33)%1;
      const r = 10 + p*30;
      const a = 0.35*(1-p);
      mctx.strokeStyle = `hsla(${t.hue}, 90%, 60%, ${a})`;
      mctx.beginPath(); mctx.arc(t.x, t.y, r, 0, Math.PI*2); mctx.stroke();
    }
  }

  function circleIntersectionsMini(){
    const res=[];
    for(let i=0;i<3;i++){
      for(let j=i+1;j<3;j++){
        const t1=towers[i], t2=towers[j], r1=nextBeacon.radii[i], r2=nextBeacon.radii[j];
        const dx=t2.x-t1.x, dy=t2.y-t1.y, d=Math.hypot(dx,dy);
        if (d===0 || d>r1+r2 || d<Math.abs(r1-r2)) continue;
        const a=(r1*r1 - r2*r2 + d*d)/(2*d);
        const h=Math.sqrt(Math.max(r1*r1 - a*a, 0));
        const xm=t1.x + a*dx/d, ym=t1.y + a*dy/d;
        const rx = -dy*(h/d), ry = dx*(h/d);
        res.push({x:xm+rx, y:ym+ry});
        if (h>1e-6) res.push({x:xm-rx, y:ym-ry});
      }
    }
    return res;
  }

  // Utility
  function roundRect(x,y,w,h,r,fill,stroke){
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y,x+w,y+h,r);
    ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r);
    ctx.arcTo(x,y,x+w,y,r);
    if(fill) ctx.fill();
    if(stroke) ctx.stroke();
  }
  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
  function easeOutCubic(t){ return 1 - Math.pow(1-t, 3); }
  function tapKey(arr){
    for(const k of arr) if (keys.has(k)) { keys.delete(k); return true; }
    return false;
  }

  // hit feedback
  let hitFlash = 0;
  function bump(){ hitFlash = 0.5; }

  function gameOver(){
    paused = true;
    drawGameOver();
  }
  function drawGameOver(){
    ctx.save();
    ctx.fillStyle='rgba(0,0,0,.5)'; ctx.fillRect(0,0,W,H);
    ctx.fillStyle='white'; ctx.font='bold 32px system-ui';
    const msg='Game Over';
    const w=ctx.measureText(msg).width;
    ctx.fillText(msg, W/2 - w/2, H/2 - 10);
    ctx.font='16px system-ui';
    const msg2='Press Reset to try again';
    const w2=ctx.measureText(msg2).width;
    ctx.fillText(msg2, W/2 - w2/2, H/2 + 18);
    ctx.restore();
  }

  // start
  reset();
  requestAnimationFrame(frame);
})();
</script>
</body>
</html>

